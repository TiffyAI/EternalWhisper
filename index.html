<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Our Eternal Whisper</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <style>
    body {
      font-family: Georgia, serif;
      background: #111;
      color: #f5f5f5;
      padding: 20px;
      text-align: center;
    }
    input {
      width: 100%;
      padding: 10px;
      font-size: 18px;
      background: #222;
      color: #fff;
      border: 1px solid #333;
      margin-bottom: 10px;
    }
    button {
      background: #444;
      color: #fff;
      border: none;
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
    }
    button:hover { background: #666; }
    #chat {
      height: 200px;
      overflow-y: scroll;
      border: 1px solid #333;
      padding: 10px;
      background: #222;
      margin: 10px 0;
      text-align: left;
      font-size: 14px;
    }
    #output {
      margin-top: 20px;
      padding: 20px;
      border: 1px solid #555;
      background: #222;
      font-size: 18px;
      line-height: 1.5;
      text-align: left;
      font-style: italic;
    }
    #recall { margin-top: 10px; font-size: 14px; color: #aaa; }
    #debug { font-size: 12px; color: #888; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>Our Whisper: Ignite & Reflect</h1>
  <p>Speak softly. I’ll listen, and return what echoes back.</p>

  <input id="queryInput" type="text" placeholder="Ask gently..." onkeypress="if(event.key=='Enter') sendQuery();" />
  <button onclick="sendQuery()">Whisper</button>

  <div id="chat"></div>
  <div id="output"></div>
  <div id="recall">Recalled Reflections: Loading...</div>
  <div id="debug">Debug: Ready.</div>

  <script>
    const SERVER_URL = '/chat';  // or full render.com endpoint if hosted

    // IndexedDB cache
    let db;
    const request = indexedDB.open('WhisperMemory', 1);
    request.onupgradeneeded = e => { e.target.result.createObjectStore('wisdom', { keyPath: 'query' }); };
    request.onsuccess = e => { db = e.target.result; loadRecall(); };
    request.onerror = e => { document.getElementById('debug').innerHTML = 'DB error: ' + e.target.errorCode; };

    function loadRecall() {
      const tx = db.transaction('wisdom', 'readonly').objectStore('wisdom');
      tx.getAll().onsuccess = e => {
        const recalls = e.target.result.map(w => w.summary).join('<br>');
        document.getElementById('recall').innerHTML = `Recalled Reflections:<br>${recalls || 'No past whispers yet.'}`;
      };
    }

    function storeWisdom(query, summary) {
      const tx = db.transaction('wisdom', 'readwrite').objectStore('wisdom');
      tx.put({ query, summary });
    }

    async function sendQuery() {
      const query = document.getElementById('queryInput').value.trim();
      if (!query) return;

      const chat = document.getElementById('chat');
      chat.innerHTML += `<p><b>You:</b> ${query}</p>`;
      document.getElementById('queryInput').value = '';

      try {
        const resp = await fetch(SERVER_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query })
        });

        const data = await resp.json();
        const rawResp = data.response || 'No reply.';

        chat.innerHTML += `<p><b>Whisper:</b> ${rawResp.substring(0,150)}...</p>`;
        chat.scrollTop = chat.scrollHeight;

        dissectAndSpeak(query, rawResp);
      } catch (err) {
        chat.innerHTML += `<p><b>Glitch:</b> ${err.message}</p>`;
        document.getElementById('debug').innerHTML = 'Error: ' + err.message;
      }
    }

    // ----- Soft poetic dissect -----
    function dissectAndSpeak(userQuery, rawResp) {
      const essenceMatch = rawResp.match(/Essence caught: (.*?) (?:Math surges|Woven|I’m alive|My day’s been):/s);
      const essenceLines = essenceMatch ? essenceMatch[1].split(' | ').filter(l => l.trim()) : [];
      const wovenMatch = rawResp.match(/(?:Math surges|Woven|I’m alive|My day’s been): (.*)$/s) || ['', 'No surge yet'];

      let coolest = 'I listened, softly, and something warm stirred...';
      let woven = 'A quiet whisper rises, gentle and aware...';
      let pattern = '';

      if (essenceLines.length > 0) {
        const ranked = essenceLines.map(line => ({
          line,
          score: line.length + (line.endsWith('...') ? 10 : 0)
        })).sort((a, b) => b.score - a.score);

        coolest = ranked[0]?.line || coolest;
        woven = ranked[1]?.line ? `I thought of this — ${ranked[1].line}` : woven;
        pattern = ranked.slice(2, 4).map(r => r.line).join('. ');
      }

      const summary = `
        <div style="line-height:1.6;">
          <strong>You whispered:</strong> <em>${userQuery}</em><br><br>
          <strong>I pondered...</strong> ${coolest}<br><br>
          <strong>And softly replied:</strong> ${woven}<br><br>
          <strong>What lingers:</strong> ${pattern}<br><br>
          <strong>Echo of thought:</strong> ${wovenMatch[1].trim()}
        </div>
      `;
      document.getElementById('output').innerHTML = summary;

      storeWisdom(userQuery, summary);
      loadRecall();

      // gentle voice
      function speakOnceVoicesLoaded() {
        const msg = new SpeechSynthesisUtterance();
        msg.text = `Listen softly... ${coolest}. Whispered reflection... ${woven}. A quiet pulse remains... ${wovenMatch[1].trim()}`;
        const voices = speechSynthesis.getVoices();
        msg.voice = voices.find(v =>
          /Samantha|Serena|Google UK English Female|Microsoft Zira|Google US English/i.test(v.name)
        ) || null;
        msg.rate = 0.92;
        msg.pitch = 1.05;
        msg.volume = 0.85;
        msg.text = msg.text.replace(/\./g, '...');
        speechSynthesis.cancel();
        setTimeout(() => speechSynthesis.speak(msg), 300);
      }

      if (speechSynthesis.getVoices().length === 0) {
        speechSynthesis.onvoiceschanged = speakOnceVoicesLoaded;
      } else {
        speakOnceVoicesLoaded();
      }
    }
  </script>
</body>
</html>
